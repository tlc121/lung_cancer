//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Utils
//  @ File Name : InferLocalPathologyUtils.cpp
//  @ Date : 2019/8/15
//  @ Author : weiping liu
//
//

#include <memory>
#include "DataObj.h"
#include "InferLocalPathologyUtils.h"
#include "IFPipelinePathologyUtilsOUT.h"
#include "IFPipelinePathologyUtilsIn.h"
#include <vector>

namespace ALPHA
{
	namespace Pathology 
	{
		namespace PTUtils
		{
			InferLocalPathologyUtils::InferLocalPathologyUtils() : COMM::InferLocalBase()
			{

			}

			InferLocalPathologyUtils::~InferLocalPathologyUtils()
			{

			}

			cv::Mat InferLocalPathologyUtils::resize_image(cv::Mat in_img, const int input_width, const int input_height)
			{
				int ih = input_height;
				int iw = input_width;

				int h = in_img.size().height;
				int w = in_img.size().width;
				float scale = min(float(iw) / w, float(ih) / h);

				int nw = int(scale * w);
				int nh = int(scale * h);

				int dw = (iw - nw) / 2;
				int dh = (ih - nh) / 2;

				cv::Size dsize = cv::Size(in_img.cols, in_img.rows);
				cv::Mat resized_img = cv::Mat(dsize, CV_8UC3);
				cv::resize(in_img, resized_img, cv::Size(nw, nh), 2);

				cv::Mat out_img(input_width, input_height, CV_8UC3, cv::Scalar::all(0));
				for (int i = dh; i < dh + nh; i++) {
					for (int j = dw; j < dw + nw; j++) {
						uchar pixel_r = resized_img.at<cv::Vec3b>(i - dh, j - dw)[0];
						uchar pixel_g = resized_img.at<cv::Vec3b>(i - dh, j - dw)[1];
						uchar pixel_b = resized_img.at<cv::Vec3b>(i - dh, j - dw)[2];

						uchar* r = &out_img.at<cv::Vec3b>(i, j)[0];
						uchar* g = &out_img.at<cv::Vec3b>(i, j)[1];
						uchar* b = &out_img.at<cv::Vec3b>(i, j)[2];

						*r = pixel_r;
						*g = pixel_g;
						*b = pixel_b;
					}
				}
				return out_img;

			}

			bool InferLocalPathologyUtils::Mat2ChannelFirstTensor(cv::Mat in_img, tensorflow::Tensor& out_tensor, const int batch)
			{
				auto out_tensorMapped = out_tensor.tensor<float, 4>();
				int height = in_img.rows;
				int width = in_img.cols;
				int depth = in_img.channels();
				const float* data = (float*)in_img.data;
				for (int y = 0; y < height; y++)
				{
					const float* dataRow = data + (y * width * depth);
					for (int x = 0; x < width; x++)
					{
						const float* dataPixel = dataRow + (x * depth);
						for (int c = 0; c < depth; c++)
						{
							const float* dataValue = dataPixel + c;
							out_tensorMapped(batch, c, y, x) = *dataValue;
						}
					}
				}
				return true;
			}

			cv::Mat InferLocalPathologyUtils::normalize_image(cv::Mat in_img)
			{
				int rows = in_img.rows;
				int cols = in_img.cols;

				//create a float Mat to store the pixel intensity
				cv::Mat norm_img = cv::Mat(rows, cols, CV_32FC3, cv::Scalar::all(0));
				for (int i = 0; i < rows; i++) {
					for (int j = 0; j < cols; j++) {
						cv::Vec3b pixel = in_img.at<cv::Vec3b>(i, j);
						uchar red = pixel.val[0];
						uchar green = pixel.val[1];
						uchar blue = pixel.val[2];

						float replace_b = blue / 255.0;
						float replace_g = green / 255.0;
						float replace_r = red / 255.0;

						float* r = &norm_img.at<cv::Vec3f>(i, j)[0];
						float* g = &norm_img.at<cv::Vec3f>(i, j)[1];
						float* b = &norm_img.at<cv::Vec3f>(i, j)[2];

						*b = replace_b;
						*g = replace_g;
						*r = replace_r;

					}
				}
				return norm_img;
			}


			//***************************************************************************************************************************************
			std::vector<std::vector<float>> InferLocalPathologyUtils::postprocess(std::vector<std::vector<float>> input, std::vector<int> ori_shape, unsigned int input_size, float score_threshold) {
				int row = input.size();
				int col = input[0].size();

				int ori_h = ori_shape[0];
				int ori_w = ori_shape[1];

				int final_dimension = 0;
				std::vector<std::vector<float>> output;
				std::vector<std::vector<float>> pred_xywh(row, std::vector<float>(4, 0.0));//bbox
				std::vector<std::vector<float>> pred_conf(row, std::vector<float>(1, 0.0));//confidence
				std::vector<std::vector<float>> pred_prob(row, std::vector<float>(col - 5, 0.0));//classification 0 or 1
				std::vector<std::vector<bool>> scale_mask(row, std::vector<bool>(1, true));//matrix which stores some invalid box scale
				std::vector<std::vector<int>> classes(row, std::vector<int>(1, 0)); //which class has the highest probility
				std::vector<std::vector<bool>> score_mask(row, std::vector<bool>(1, false)); //box whose score is higher than threshold
				std::vector<std::vector<bool>> mask(row, std::vector<bool>(1, false)); //final decision of bboxes

				//give pred_xywh, pred_conf, pred_prob value from the input
				for (int i = 0; i < row; i++) {
					float c_x = input[i][0];
					float c_y = input[i][1];
					float width = input[i][2];
					float height = input[i][3];
					pred_xywh[i][0] = c_x;
					pred_xywh[i][1] = c_y;
					pred_xywh[i][2] = width;
					pred_xywh[i][3] = height;
				}

				for (int i = 0; i < row; i++) {
					float conf = input[i][4];
					pred_conf[i][0] = conf;
				}

				for (int i = 0; i < row; i++) {
					for (int j = 0; j < col - 5; j++) {
						float prob = input[i][j + 5];
						pred_prob[i][j] = prob;
					}
				}


				//save the boundingbox info into a new matrix
				std::vector<std::vector<float>> pred_coord(row, std::vector<float>(4, 0.0)); //xmin, ymin, xmax, ymax
				for (int i = 0; i < row; i++) {
					float c_x = pred_xywh[i][0];
					float c_y = pred_xywh[i][1];
					float width = pred_xywh[i][2];
					float height = pred_xywh[i][3];
					float minx, miny, maxx, maxy;
					minx = c_x - width / 2;
					miny = c_y - height / 2;
					maxx = c_x + width / 2;
					maxy = c_y + height / 2;
					pred_coord[i][0] = minx;
					pred_coord[i][1] = miny;
					pred_coord[i][2] = maxx;
					pred_coord[i][3] = maxy;
				}


				float resize_ratio = min(float(input_size) / ori_h, float(input_size) / ori_w);
				float dw = float(input_size - resize_ratio * ori_w) / 2;
				float dh = float(input_size - resize_ratio * ori_h) / 2;


				for (int i = 0; i < row; i++) {
					for (int j = 0; j < 4; j += 2) {
						float replace = (pred_coord[i][j] - dw) / resize_ratio;
						pred_coord[i][j] = replace;
					}
				}

				for (int i = 0; i < row; i++) {
					for (int j = 1; j < 4; j += 2) {
						float replace = (pred_coord[i][j] - dh) / resize_ratio;
						pred_coord[i][j] = replace;
					}
				}

				//clip some bboxes which are out of range
				for (int i = 0; i < row; i++) {
					float* x = &pred_coord[i][0];
					float* y = &pred_coord[i][1];
					float* w = &pred_coord[i][2];
					float* h = &pred_coord[i][3];
					if (*x < 0) {
						*x = 0;
					}
					if (*y < 0) {
						*y = 0;
					}
					if (*w > ori_w) {
						*w = ori_w;
					}
					if (*h > ori_h) {
						*h = ori_h;
					}

					if (*x > * w || *y > * h) {
						*x = 0;
						*y = 0;
						*w = 0;
						*h = 0;
					}
				}

				//discard some invalid boxes
				for (int i = 0; i < row; i++) {
					float x = pred_coord[i][0];
					float y = pred_coord[i][1];
					float w = pred_coord[i][2];
					float h = pred_coord[i][3];
					float replace = std::sqrt((w - x) * (h - y));
					if (replace < 0 || replace > 999999999999)
						scale_mask[i][0] = false;
				}

				//discard box whose score is lower than threshold
				for (int i = 0; i < row; i++) {
					float max_prob = 0.0;
					int max_pos = 0;
					for (int j = 0; j < col - 5; j++) {
						float temp = pred_prob[i][j];
						if (temp > max_prob) {
							max_prob = temp;
							max_pos = j;
						}
					}
					classes[i][0] = max_pos;
				}


				for (int i = 0; i < row; i++) {
					float score_bbox = pred_conf[i][0];
					float prob_bbox = pred_prob[i][classes[i][0]];
					if (score_bbox * prob_bbox > score_threshold) {
						score_mask[i][0] = true;
					}
				}


				for (int i = 0; i < row; i++) {
					if (score_mask[i][0] && scale_mask[i][0]) {
						mask[i][0] = true;
					}
				}

				for (int i = 0; i < row; i++) {
					if (mask[i][0]) {
						std::vector<float> temp(6);
						temp[0] = pred_coord[i][0];
						temp[1] = pred_coord[i][1];
						temp[2] = pred_coord[i][2];
						temp[3] = pred_coord[i][3];
						temp[4] = pred_conf[i][0];
						temp[5] = float(classes[i][0]);
						output.push_back(temp);
					}
				}
				return output;
			}
			//***************************************************************************************************************************************
			std::vector<std::vector<float>> InferLocalPathologyUtils::nms(std::vector<std::vector<float>> input, float iou_threshold) {
				int num_bboxes = input.size();
				std::set<float> all_classes; //hashset to store all classes
				std::vector<std::vector<float>> output;
				for (int i = 0; i < num_bboxes; i++) {
					all_classes.insert(input[i][5]);
				}

				//loop in all classes
				for (std::set<float>::iterator it = all_classes.begin(); it != all_classes.end(); it++) {
					float class_ = *it;
					std::vector<std::vector<float>> cls_bboxes;
					for (int i = 0; i < num_bboxes; i++) {
						if (input[i][5] == class_) {
							std::vector<float> temp(6);
							temp[0] = input[i][0];
							temp[1] = input[i][1];
							temp[2] = input[i][2];
							temp[3] = input[i][3];
							temp[4] = input[i][4];
							temp[5] = input[i][5];
							cls_bboxes.push_back(temp);
						}
					}

					//nms
					while (cls_bboxes.size() > 0) {
						int max_ind = -1;
						float max_conf = 0;
						int num = cls_bboxes.size();
						std::vector<std::vector<float>> other_bboxes;
						for (int i = 0; i < num; i++) {
							float conf = cls_bboxes[i][4];
							if (conf > max_conf) {
								if (max_ind != -1) {
									other_bboxes.push_back(cls_bboxes[max_ind]);
								}
								max_conf = conf;
								max_ind = i;
							}
							else {
								other_bboxes.push_back(cls_bboxes[i]);
							}
						}

						std::vector<float> best_box = cls_bboxes[max_ind];
						cls_bboxes.erase(std::begin(cls_bboxes) + max_ind); //remove the best box in vector
						output.push_back(best_box);
						std::vector<float> iou_res = this->iou_bboxes(best_box, other_bboxes);
						std::vector<float> weights(iou_res.size(), 1.0);
						for (int i = 0; i < iou_res.size(); i++) {
							if (iou_res[i] > iou_threshold) {
								weights[i] = 0.0;
							}
						}

						auto cls_bboxes_temp = cls_bboxes;
						cls_bboxes.clear();
						for (int i = 0; i < iou_res.size(); i++) {
							other_bboxes[i][4] = other_bboxes[i][4] * weights[i];
							if (other_bboxes[i][4] > 0) {
								cls_bboxes.push_back(cls_bboxes_temp[i]);
							}
						}
					}
				}
				return output;
			}
			//***************************************************************************************************************************************
			std::vector<float> InferLocalPathologyUtils::iou_bboxes(std::vector<float> target_box, std::vector<std::vector<float>> other_bboxes) {
				std::vector<float> iou_res;
				for (int i = 0; i < other_bboxes.size(); i++) {
					std::vector<float> temp = other_bboxes[i];
					iou_res.push_back(this->iou(target_box, temp));
				}
				return iou_res;
			}
			//***************************************************************************************************************************************
			float InferLocalPathologyUtils::iou(std::vector<float> box1, std::vector<float> box2) {
				float minx1 = box1[0];
				float miny1 = box1[1];
				float maxx1 = box1[2];
				float maxy1 = box1[3];

				float minx2 = box2[0];
				float miny2 = box2[1];
				float maxx2 = box2[2];
				float maxy2 = box2[3];

				float box1_area = (maxx1 - minx1) * (maxy1 - miny1);
				float box2_area = (maxx2 - minx2) * (maxy2 - miny2);

				float union_minx = std::max(minx1, minx2);
				float union_miny = std::max(miny1, miny2);
				float union_maxx = min(maxx1, maxx2);
				float union_maxy = min(maxy1, maxy2);

				float width = std::max(union_maxx - union_minx, float(0.0));
				float height = std::max(union_maxy - union_miny, float(0.0));

				float intersection = width * height;
				float iou_ = intersection / (box1_area + box2_area - intersection);
				return iou_;
			}
			//***************************************************************************************************************************************
			COMM::DataObj* InferLocalPathologyUtils::predict(COMM::DataObj* dataObj, const std::string& modelName)
			{
				IFPipelinePathologyUtilsIn* input_Utils = dynamic_cast<IFPipelinePathologyUtilsIn*>(dataObj);
				IFPipelinePathologyUtilsOut* output_Utils(new IFPipelinePathologyUtilsOut());
				libconfig::Config mConfig;
				COMM::loadCfg(input_Utils->m_config_path, mConfig);
				const libconfig::Setting& root = mConfig.getRoot();
				const libconfig::Setting& shape = root["PTUTILS_PREPROCESS"]["DET_INPUT_SHAPE"];
				int width = shape[0];
				int height = shape[1];
				std::string input_node = mConfig.lookup("PT_UTILS.INPUT_NODE");
				std::string output_node_sbbox = mConfig.lookup("PT_UTILS.OUTPUT_NODE_1");
				std::string output_node_mbbox = mConfig.lookup("PT_UTILS.OUTPUT_NODE_2");
				std::string output_node_lbbox = mConfig.lookup("PT_UTILS.OUTPUT_NODE_3");
				float prob_threshold = mConfig.lookup("PT_UTILS.PROB_THRESHOLD");
				float iou_threshold = mConfig.lookup("PT_UTILS.IOU_THRESHOLD");
				int num_classes = mConfig.lookup("PT_UTILS.NUM_CLASSES");

				// step 1: read image
				std::string img_path = input_Utils->m_img_path;
				std::cout << img_path << std::endl;
				cv::Mat image = cv::imread(img_path);

				//original shape of image
				std::vector<int> original_shape;
				int ori_h = image.size().height;
				int ori_w = image.size().width;
				original_shape.push_back(ori_h);
				original_shape.push_back(ori_w);

				if (image.empty()) {
					LOG4CPLUS_WARN(COMM::MyLogger::getInstance()->m_rootLog, "Could not open image: " << img_path);
					LOG4CPLUS_WARN(COMM::MyLogger::getInstance()->m_rootLog, "Is it broken? ");
					output_Utils->image_broken = true;
					return output_Utils;
				}

				// step2: preprocess image
				cv::cvtColor(image, image, cv::COLOR_BGR2RGB);
				image = resize_image(image, width, height);
				image = normalize_image(image);
				//cv::namedWindow("xx", cv::WINDOW_AUTOSIZE);
				//cv::imshow("xx", image);
				//cv::waitKey(0);

				// step 3: load det model
				/*std::string graph_path = model_path;
				if (!ReadBinaryProto(tensorflow::Env::Default(), graph_path, &graph_def).ok())
				{
					std::cout << "load .pb failed, Plz check the path" << std::endl;
				}
				else
				{
					std::cout << "load model successfully!" << std::endl;
				}*/

				/*tensorflow::SessionOptions sess_opt;
				std::unique_ptr<tensorflow::Session> session;
				sess_opt.config.mutable_gpu_options()->set_allow_growth(true);

				(&session)->reset(NewSession(sess_opt));
				if (!session->Create(graph_def).ok()) {
					std::cout << "Create graph failed" << std::endl;
				}*/

				tensorflow::Session* session = this->m_session;
				tensorflow::Tensor img_tensor(tensorflow::DT_FLOAT, tensorflow::TensorShape({ 1, width, height, 3 }));
				float* p = img_tensor.flat<float>().data();
				cv::Mat img_tensor_mat(width, height, CV_32FC3, p);
				image.convertTo(img_tensor_mat, img_tensor_mat.type());

				std::string input = input_node;

				//three feature maps
				std::vector<tensorflow::Tensor> pred_bbox;

				//three output node
				std::string output_sbbox = output_node_sbbox;
				std::string output_mbbox = output_node_mbbox;
				std::string output_lbbox = output_node_lbbox;

				//run inference three times
				std::pair<std::string, tensorflow::Tensor>img_feed(input, img_tensor);

				const std::string trainable = "training:0";
				tensorflow::Tensor trainable_tensor(tensorflow::DT_BOOL, tensorflow::TensorShape());
				auto t_trainable = trainable_tensor.scalar<bool>();
				t_trainable(0) = false;
				std::pair<std::string, tensorflow::Tensor>img_feed_2_trainable(trainable, trainable_tensor);

				tensorflow::Status status_1 = session->Run({ img_feed,img_feed_2_trainable }, { output_sbbox, output_mbbox, output_lbbox }, {}, &pred_bbox);
				std::cout << "predict done!" << std::endl;
				tensorflow::Tensor t_sbbox = pred_bbox[0];
				tensorflow::Tensor t_mbbox = pred_bbox[1];
				tensorflow::Tensor t_lbbox = pred_bbox[2];

				auto probilities_sbbox = t_sbbox.flat<float>();
				auto probilities_mbbox = t_mbbox.flat<float>();
				auto probilities_lbbox = t_lbbox.flat<float>();


				//create a two dimension matrix with size 10647*6 and concat three feature maps
				unsigned int num_type = num_classes;
				unsigned int col = 5 + num_type;
				unsigned int row = probilities_sbbox.size() / col + probilities_mbbox.size() / col + probilities_lbbox.size() / col;
				std::vector<std::vector<float>> concat(row, std::vector<float>(col, 0.0));
				unsigned int j = 0;
				for (unsigned int i = 0; i < probilities_sbbox.size(); i = i + col) {
					for (unsigned int k = 0; k < col; k++) {
						concat[j][k] = probilities_sbbox(i + k);
					}
					j += 1;
				}

				for (unsigned int i = 0; i < probilities_mbbox.size(); i = i + col) {
					for (unsigned int k = 0; k < col; k++) {
						concat[j][k] = probilities_mbbox(i + k);
					}
					j += 1;
				}

				for (unsigned int i = 0; i < probilities_lbbox.size(); i = i + col) {
					for (unsigned int k = 0; k < col; k++) {
						concat[j][k] = probilities_lbbox(i + k);
					}
					j += 1;
				}

				int l = 5;
				auto bboxes = this->postprocess(concat, original_shape, width, prob_threshold);
				//if no boxes detected, return image not clear
				if (bboxes.size() == 0) {
					output_Utils->image_notclear = true;
					std::cout << "no box" << std::endl;
					return output_Utils;
				}
				bboxes = this->nms(bboxes, iou_threshold);
				//take bbox
				std::vector<float> final_bbox = bboxes[0];
				std::vector<unsigned int> ret_bbox;
				ret_bbox.push_back(int(final_bbox[0]));
				ret_bbox.push_back(int(final_bbox[1]));
				ret_bbox.push_back(int(final_bbox[2]));
				ret_bbox.push_back(int(final_bbox[3]));
				output_Utils->bbox = ret_bbox;

				//3 point 
				std::pair<unsigned int, unsigned int> point1;
				std::pair<unsigned int, unsigned int> point2;
				std::pair<unsigned int, unsigned int> point3;

				unsigned int minx = ret_bbox[0];
				unsigned int miny = ret_bbox[1];
				unsigned int maxx = ret_bbox[2];
				unsigned int maxy = ret_bbox[3];

				point1 = std::make_pair(minx + 0.33 * (maxx - minx), miny + 0.33 * (maxx - minx));
				point2 = std::make_pair(minx + 0.66 * (maxx - minx), miny + 0.33 * (maxx - minx));
				point3 = std::make_pair(minx + 0.5 * (maxx - minx), miny + 0.66 * (maxx - minx));

				output_Utils->pos.push_back(point1);
				output_Utils->pos.push_back(point2);
				output_Utils->pos.push_back(point3);

				return output_Utils;
			}
		}
	}
}