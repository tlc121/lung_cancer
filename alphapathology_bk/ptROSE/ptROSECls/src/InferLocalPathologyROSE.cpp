//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : ROSE
//  @ File Name : InferLocalPathologyROSE.cpp
//  @ Date : 2019/8/15
//  @ Author : weiping liu
//
//

#include <memory>
#include <typeinfo>
#include <math.h>
#include <typeinfo>

#include "DataObj.h"
#include "InferLocalPathologyROSE.h"
#include "IFPipelinePathologyIn.h"
#include "CommonUtils.h"

#include "openslide-features.h"
#include "openslide.h"

namespace ALPHA
{
	namespace ROSE
	{
		COMM::DataObj* InferLocalPathologyROSE::predict(COMM::DataObj* dataObj, const std::string& modelName)
		{
			IFPipelinePathologyIn* input_ROSE = dynamic_cast<IFPipelinePathologyIn*>(dataObj);
			IFPipelinePathologyROSEOut* output_ROSE = new IFPipelinePathologyROSEOut();
			int cut_width = 512;
			int cut_height = 512;

			if (input_ROSE->m_format_dismatch)
			{
				output_ROSE->format_wrong = true;
				LOG4CPLUS_ERROR(COMM::MyLogger::getInstance()->m_rootLog, " Image format wrong.");
				return output_ROSE;
			}
			LOG4CPLUS_INFO(COMM::MyLogger::getInstance()->m_rootLog, "Start reading svs: " << input_ROSE->m_svs_path.c_str());
			if (!openslide_can_open(input_ROSE->m_svs_path.c_str()))
			{
				output_ROSE->file_broken = true;
				LOG4CPLUS_ERROR(COMM::MyLogger::getInstance()->m_rootLog, " Could not open slide.");
				return output_ROSE;
			}
			openslide_t* slide = openslide_open(input_ROSE->m_svs_path.c_str());
			if (openslide_get_error(slide) != NULL)
			{
				openslide_close(slide);
				LOG4CPLUS_ERROR(COMM::MyLogger::getInstance()->m_rootLog, "Could not read slide.");
				output_ROSE->file_broken = true;
				return output_ROSE;
			}
			openslide_close(slide);

			bool allIOComplete = false;
			IOThread* io_1 = new IOThread(input_ROSE, 0, 0, cut_width, cut_height);
			IOThread* io_2 = new IOThread(input_ROSE, 0, 1, cut_width, cut_height);
			IOThread* io_3 = new IOThread(input_ROSE, 1, 0, cut_width, cut_height);
			IOThread* io_4 = new IOThread(input_ROSE, 1, 1, cut_width, cut_height);
			AIThread* ai = new AIThread(input_ROSE->m_config_path, io_1, output_ROSE, &allIOComplete);
			io_1->start();
			io_2->start();
			io_3->start();
			io_4->start();
			ai->start();
			io_1->wait();
			io_2->wait();
			io_3->wait();
			io_4->wait();
			allIOComplete = true;
			ai->wait();

			delete io_1;
			delete io_2;
			delete io_3;
			delete io_4;
			delete ai;

			LOG4CPLUS_INFO(COMM::MyLogger::getInstance()->m_rootLog, "Prediction complete.");

			output_ROSE->sample_name = input_ROSE->m_slide_name;
			output_ROSE->num_blur_patch = io_1->m_num_blur + io_2->m_num_blur + io_3->m_num_blur + io_4->m_num_blur;
			output_ROSE->num_broken_patch = io_1->m_num_broken + io_2->m_num_broken + io_3->m_num_broken + io_4->m_num_broken;
			output_ROSE->num_cell_patch = io_1->m_num_images + io_2->m_num_images + io_3->m_num_images + io_4->m_num_images;
			output_ROSE->num_bbox = output_ROSE->num_tumor_patch ;
			output_ROSE->ratio_blur = output_ROSE->num_blur_patch * 1.0 / output_ROSE->num_cell_patch;

			return output_ROSE;
		}
	}
}