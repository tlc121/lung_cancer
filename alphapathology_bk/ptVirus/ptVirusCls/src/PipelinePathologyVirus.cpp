//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : ROSE
//  @ File Name : PipelinePathologyROSE.cpp
//  @ Date : 2019/8/15
//  @ Author : weiping liu
//
//


#include "PipelinePathologyVirus.h"
#include "IFPipelinePathologyVirusOut.h"
#include "PipelineElementPathologyVirusCls.h"
#include "CommonUtils.h"
#include "IFPipelinePathologyVirusIn.h"

namespace ALPHA
{
	namespace VIRUS
	{
		PipelinePathologyVirus::PipelinePathologyVirus(): COMM::PipelineAlgorithmExecutor(),
			ptrPipelineIn(nullptr), ptrPipelineOut(nullptr)
		{

		}
		PipelinePathologyVirus::~PipelinePathologyVirus()
		{

		}

		void PipelinePathologyVirus::setUpPipeline()
		{
			LOG4CPLUS_INFO(COMM::MyLogger::getInstance()->m_rootLog, "PipelinePathologyVirus::setUpPipeline()!");

			// step 1: classification
			std::shared_ptr<PipelineElementPathologyVirusCls>
				ptrPipelineElementPathologyVirusCls(new PipelineElementPathologyVirusCls());
			listElement.push_back(ptrPipelineElementPathologyVirusCls);
			
		}

		void PipelinePathologyVirus::executePipeline()
		{
			std::list<std::shared_ptr<COMM::PipelineElementBase>>::iterator
				itPre = listElement.begin();
			auto itCurr = itPre;
			if (itCurr != listElement.end())
			{
				++itCurr;
			}
			else
			{
				LOG4CPLUS_ERROR(COMM::MyLogger::getInstance()->m_rootLog, "PipelinePathologyVirus need at least one algorithmElement! Quite pipeline computation!");
				return;
			}
			if (ptrPipelineIn == nullptr)
			{
				LOG4CPLUS_ERROR(COMM::MyLogger::getInstance()->m_rootLog, "nullptr input in PipelinePathologyVirus! Quite pipeline computation!");
				return;
			}
			(*itPre)->setInput(ptrPipelineIn);
			for (; itCurr != listElement.end(); ++itCurr, ++itPre)
			{
				(*itPre)->update();
				(*itCurr)->setInput((*itPre)->getOutput());
			}
			(*itPre)->update();
			//std::shared_ptr<COMM::DataObj> ptrOutput = (*itPre)->getOutput();
			ptrPipelineOut = std::dynamic_pointer_cast<IFPipelinePathologyVirusOut>((*itPre)->getOutput());
		}

		void PipelinePathologyVirus::setInput(std::shared_ptr<COMM::DataObj> Input)
		{
			ptrPipelineIn = std::dynamic_pointer_cast<ALPHA::VIRUS::IFPipelinePathologyIn>(Input);
			std::vector<std::string> ptFolder;// = ptrPipelineIn->getImagePaths();
			ptFolder = ptrPipelineIn->m_image_list;

			if (ptFolder.empty())
			{
				LOG4CPLUS_INFO(COMM::MyLogger::getInstance()->m_rootLog, "The image path is empty!");
				return;
			}
		}

		std::shared_ptr<COMM::DataObj> PipelinePathologyVirus::getOutput()
		{
			//TO DO: need to edit for the output
			//ptrPipelineOut = std::make_shared<IFPipelinePathologyVirusOut>(ptrPipelineOut);
			LOG4CPLUS_INFO(COMM::MyLogger::getInstance()->m_rootLog, "Inference Done!");
			//return 
			return ptrPipelineOut;
		}
	}
}